import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class _658_Find_K_Closest_Elements {

    public static void main(String[] args) {

        List<Integer> arr = new ArrayList<Integer>();

        arr.add(100);arr.add(200);arr.add(300);arr.add(400);arr.add(500);arr.add(600);arr.add(700);

        int k = 5;   int x = 2;

        Solution_1 solution_1 = new Solution_1();

        System.out.println(solution_1.findClosestElements(arr,k,x));
    }

    /** 題目意思講解： https://www.youtube.com/watch?v=XlHoJa1DrZg  **/

    /** Binary Search and Two Pointers **/
    public static class Solution_1 {

        public List<Integer> findClosestElements(List<Integer> arr, int k, int x) {

            /** 1. 拿到array的大小  **/
            int n = arr.size();

            /** 2. 如果 x 在 array的左邊，就  **/
            if (x <= arr.get(0)) {
                return arr.subList(0, k);

            /** 3. 如果 x 在 array的右邊，就 **/
            } else if (arr.get(n - 1) <= x) {
                return arr.subList(n - k, n);

            /** 4. 其他情況：x 取值在 中間，但又不存在與array **/
            } else {

                /** ~1 找到 x 的位置， x 取值在 中間，但又不存在與array，那麼返回 負數，比如，{3,6,9} 查找7，返回 -3   **/
                int index = Collections.binarySearch(arr, x);

                /** ~2 難道還會小於 0   不懂!!!!!!!!!!!!!!!!**/
                if (index < 0) index = -index - 1;

                /** ~3 製造 低 高 點   **/
                int low = Math.max/** 注意這裡是 MAX **/(0, index - k - 1),  high = Math.min/** 注意這裡是 MIN **/(arr.size() - 1, index + k - 1);

                /** ~4 只要大條件滿足，就是 (高 - 低) < (k -1) **/
                while (high - low > k - 1) {

                    /** 為何 這裡的 low會小於 0   **/
                    /** ~ 4.1  當 k 大於 x 的時候， low會小於0 |  x 和 low的距離，小過 x 和 high的距離 --> high-- **/
                    if (low < 0 || (x - arr.get(low)) <= (arr.get(high) - x))      high--;

                    /** ~ 4.1  high 超越了 array size | 或者，x 和 low的距離，大過 x 和 high的距離 --> low++ **/
                    else if (high > arr.size() - 1 || (x - arr.get(low)) > (arr.get(high) - x))      low++;

                    /** ~ 4.2 無法handle */
                    else System.out.println("unhandled case: " + low + " " + high);
                }

                /** 5. 提取答案 **/
                return arr.subList(low, high + 1);
            }
        }
    }
}
