import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.PriorityQueue;

public class _787_Cheapest_Flights_Within_K_Stops {

    public static void main(String[] args) {

        int n = 3;
        int[][] edges = {{0,1,100},{1,2,100},{0,2,500}};
        int src = 0;
        int dst = 2;
        int k = 1;

        Solution_1 solution_1 = new Solution_1();
        Solution_2 solution_2 = new Solution_2();

        System.out.println(solution_1.findCheapestPrice(n,edges,src,dst,k));
        System.out.println(solution_2.findCheapestPrice(n,edges,src,dst,k));
    }

    /** Maintain Cheapest To Target  解釋：https://leetcode.com/articles/cheapest-flights-within-k-stops/  **/
    static class Solution_1 {

        public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {

            /** 1. 制造兩排 DP  **/
            int[][] dist = new int[2][n];

            /**  dis = dist[0] and pre = dist[1] **/

            /** 2. 製造INF  **/
            int INF = Integer.MAX_VALUE / 2;

            /** 3. 填充DP的兩排  **/
            Arrays.fill(dist[0], INF);
            Arrays.fill(dist[1], INF);

            /** 4. 初始化 出發點  **/
            dist[0][src] = dist[1][src] = 0;

            /** 5. 開始戰鬥，跳 K 次  **/
            for (int i = 0; i <= K; ++i) {

                System.out.println("\n\n\n  "  );
                System.out.println("******   i= " + i  + "   ********");

                    /** ~1 遍歷所有的flights  **/
                    for (int[] edge : flights) {

//                        System.out.println( "(i & 1) = " + (i & 1) );
//                        System.out.println( "(~i & 1) = " + (~i & 1) );

                        /**  dis = dist[0] and pre = dist[1] **/

                        /** int[][] edges = {{0,1,100},{1,2,100},{0,2,500}};  **/

                        System.out.println(" ");
                        System.out.println(" ");
                        System.out.println(edge[1]);

                        /** 注釋：edge[1]是終點  **/
                        dist[ i & 1 ][ edge[1] ] = Math.min(  dist[i & 1][ edge[1] ],  dist[~i & 1][edge[0]] /** 出發點的上一次最低開銷 **/  +   edge[2] /** 當前的最低開銷 **/ );

                        for (int[] ints : dist) {
                                    System.out.println("");
                                    for (int anInt : ints) {
                                                   System.out.print(anInt + "——" );
                                    }
                        }

                    }
            }

            /** 6. 為何要 K & 1  --> 因為 K & 1 是最新更新  **/
            return dist[ K & 1 ][ dst ] < INF ? dist[ K&1 ][ dst ] : -1;
        }
    }

    /** Dijkstra's **/
    static class Solution_2 {
        public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {
            int[][] graph = new int[n][n];
            for (int[] flight: flights)
                graph[flight[0]][flight[1]] = flight[2];

            Map<Integer, Integer> best = new HashMap();

            PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> a[0] - b[0]);
            pq.offer(new int[]{0, 0, src});

            while (!pq.isEmpty()) {
                int[] info = pq.poll();
                int cost = info[0], k = info[1], place = info[2];
                if (k > K+1 || cost > best.getOrDefault(k * 1000 + place, Integer.MAX_VALUE))
                    continue;
                if (place == dst)
                    return cost;

                for (int nei = 0; nei < n; ++nei) if (graph[place][nei] > 0) {
                    int newcost = cost + graph[place][nei];
                    if (newcost < best.getOrDefault((k+1) * 1000 + nei, Integer.MAX_VALUE)) {
                        pq.offer(new int[]{newcost, k+1, nei});
                        best.put((k+1) * 1000 + nei, newcost);
                    }
                }
            }

            return -1;
        }
    }

}
