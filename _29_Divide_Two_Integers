public class _29_Divide_Two_Integers {

    public static void main(String[] args) {

        int a = 111;
        int b = 3;

        Solution_1 solution_1 = new Solution_1();
        Solution_2 solution_2 = new Solution_2();

        System.out.println(solution_1.divide(a,b));
        System.out.println(solution_2.divide(a,b));
    }


    /** 方法一： CSPIRATION + 無數據結構 **/
    public static class Solution_1 {

        public int divide(int dividend, int divisor) {

            /** 1. 製造sign，來決定正負號  **/
            int sign = 1;

            /** 2. 如果一正一負，返回 -1  **/
            if ((dividend > 0 && divisor < 0) || (dividend < 0 && divisor > 0)) sign = -1;

            /** 3. 求兩個數字的 絕對值 --> Long 是為了防止overflow **/
            long ldividend = Math.abs((long) dividend);
            long ldivisor = Math.abs((long) divisor);

            /** 4. 如果除數，比商數小，返回 0  **/
            if (ldividend < ldivisor || ldividend == 0) return 0;

            /** 5. 開始戰鬥  **/
            long lres = divide(ldividend, ldivisor);

            /** 6. 返回結果  **/
            return (int) lres;
        }

        /** 5. 開始戰鬥  **/
        public long divide(long ldividend, long ldivisor) {

            /** 5.1 如果除數，小於商數，返回 0  **/
            if (ldividend < ldivisor) return 0;

            /** 5.2 初始化 sum，為商  **/
            long sum = ldivisor;

            /** 5.3 初始化 multiple，為1  **/
            long multiple = 1;

            /** 5.4 取得sum，和multiple （每次是雙倍的 sum或者multiple）  **/
            while ((sum + sum) <= ldividend) {

                sum += sum;

                multiple += multiple;

                System.out.println("sum = " + sum + ", multiple = " + multiple);
            }

            return multiple + divide(ldividend - sum, ldivisor);
            // return multiple + divide(ldividend - sum, ldivisor);
        }
    }

    /** 方法二: BasketWang + 無數據結構 **/
    public static class Solution_2 {

        public int divide(int dividend, int divisor) {

            /** 1. 商是0，則返回最大值  **/
            if (divisor == 0) return Integer.MAX_VALUE;

            /** 2. 除數是INT最小值，邊界情況  **/
            if (dividend == Integer.MIN_VALUE) {
                if( divisor == -1) return Integer.MAX_VALUE;
                else if (divisor == 1) return Integer.MIN_VALUE;
            }

            /** 3. 防止overflow？？？why？？？  **/
            long divd = (long) dividend;
            long divs = (long) divisor;

            /** 4. 給正負號標誌  **/
            int sign = 1;

            /** 5. 確保正負號  **/
            if(divd < 0) {
                divd = -divd;
                sign = -sign;
            }

            if (divs < 0) {
                divs = -divs;
                sign = - sign;
            }

            /** 6. 初始化為 0  **/
            int res = 0;

            /** 7. 循環  **/
            while (divd >= divs) {

                        /** 7.1 製造 shift  **/
                        int shift = 0;

                        /** 7.2 如果（divs << shift）比 divd 小，繼續移位  **/
                        while ( divd >= (divs << shift) ) { shift++; }

                        /** 7.3 拿到移位后的，res值  **/
                        res += ( 1 << (shift-1) );

                        /** 7.4 更新divd  **/
                        divd -= (divs << (shift-1));
            }

            /** 8. 得出結果  **/
            return sign * res;
        }
    }
}
