### 1234.Replace-the-Substring-for-Balanced-String

#### 解法１：
比赛的时候我用的是二分法，尝试我们需要移除的substring的宽度ｋ，它的范围是[0,n]．二分的过程中，每次确定一个ｋ，就在ｓ上划过一个固定长度ｋ的窗口，查看是否在哪个位置的时候可行．

我当时写的判定标准是：如果剩余的（除去滑动窗口之外）的词频统计sum里，假设最多的频率是t，那么我们检查```diff=t*4-sum['Q']-sum['W']-sum['E']-sum['R']```，这个diff表示我们还需要多少个＂万能字符＂去填充这个＂直方图＂使得它平齐.如果diff<=k,那么就说明ｋ可行（事实上，其中多余的k-diff个万能字符我们其实可以弃用）．

这个复杂度其实是nlog(n).

#### 解法２：
本题其实用双指针来做更简单，时间复杂度为o(n).

我们提前计算好，理想情况下，最终每个字符出现的次数都应该是```x=s.size()/4```.

我们其实只要找到一段窗口，使得窗口外的词频统计sum满足每个字母的频率都小于ｋ即可！

基于这种算法，滑窗的两个指针其实是可以交替移动的．比如说当慢指针为i,快指针移动到j，满足条件．那么下一步慢指针移动到i+1,而快指针则不用动．为什么快指针不需要考察小于ｊ的位置呢？其实如果窗口```[i+1,k]```满足条件的话```（k<j)```，那么一定有```[i,k]```也满足条件，所以快指针根本就不会走到j的位置了．所以我们可以保证，并没有一个```k<j```使得```[i+1,k]```满足条件．所以快指针不需要回调．


[Leetcode Link](https://leetcode.com/problems/replace-the-substring-for-balanced-string)