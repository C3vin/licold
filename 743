import java.util.*;

public class _743_Network_Delay_Time {

    public static void main(String[] args) {

        int[][] times = {{2,1,1},{2,3,1},{3,4,2}, {4,5,3}, {3,5,4}};

        int N = 5;
        int K = 2;

        Solution_1 solution_1 = new Solution_1();
        Solution_2 solution_2 = new Solution_2();

        System.out.println( solution_1.networkDelayTime(times,N,K) );
        System.out.println( solution_2.networkDelayTime(times,N,K) );

    }
    
    /** Dijkstra's Algorithm **/
    static class Solution_2 {

        Map<Integer, Integer> dist;

        public int networkDelayTime(int[][] times, int N, int K) {

            Map<Integer, List<int[]>> graph = new HashMap();

            for (int[] edge: times) {

                if (!graph.containsKey(edge[0]))   graph.put(edge[0], new ArrayList<int[]>());

                graph.get(edge[0]).add(new int[]{edge[1], edge[2]});
            }

            /** 初始化 dist  **/
            dist = new HashMap();

            for (int node = 1; node <= N; ++node)  dist.put(node, Integer.MAX_VALUE);  /** 從1開始  **/

            /** 從K開始  **/
            dist.put(K, 0);

            boolean[] visited = new boolean[N+1];  /** 從1開始  **/

            /** Dijkstra **/
            while (true) {

                    int kNode = -1;   /** kNode的重置  **/

                    int cDist = Integer.MAX_VALUE;

                    for (int i = 1; i <= N; ++i) {

                        /** 一開始，只有K元素可以進入  **/
                        if (!visited[i] && dist.get(i) < cDist) {

                            /** 拿到最小dist的路  **/
                            cDist = dist.get(i);

                            kNode = i;
                        }
                    }

                    if (kNode < 0) break;

                    visited[kNode] = true;

                    if (graph.containsKey(kNode)){

                        for (int[] info: graph.get(kNode)) {

                            dist.put(   info[0], Math.min(   dist.get(info[0]), (dist.get(kNode) + info[1])  )    );
                        }
                    }
            }

            int ans = 0;

            for (int cand: dist.values()) {

                if (cand == Integer.MAX_VALUE) return -1;

                ans = Math.max(ans, cand);
            }

            return ans;
        }
    }

    /** DFS **/
    static class Solution_1 {

        Map<Integer, Integer> dist;

        public int networkDelayTime(int[][] times, int N, int K) {

            /** 制造 graph -->  數字 **/
            Map<Integer, List<int[]>> graph = new HashMap();

            for (int[] edge: times) {

                /** 如果graph不存在結點，就在graph插入hashmap信息  **/
                if (!graph.containsKey(edge[0])) graph.put(edge[0], new ArrayList<int[]>());

                /** 權重*/
                graph.get(edge[0]).add(new int[]{edge[2], edge[1]}); /** 算出那條路徑最短  **/
            }

            /** 遍歷 graph 的 node  **/
            for (int node: graph.keySet()) {
                Collections.sort(graph.get(node), (a, b) -> a[0] - b[0]);
            }

            dist = new HashMap();

            /** 初始化 dist  **/
            for (int node = 1; node <= N; ++node)  dist.put(node, Integer.MAX_VALUE);

            /** 遍歷每個節點 **/
            dfs(graph, K, 0);

            int ans = 0;

            /** 找到 dist 的最大值 **/
            for (int cand: dist.values()) {

                if (cand == Integer.MAX_VALUE) return -1;

                ans = Math.max(ans, cand);
            }
            return ans;
        }

        /** 消耗時間 **/
        public void dfs(Map<Integer, List<int[]>> graph, int node, int elapsed) {

            /** 如果大於原先的時間 **/
            if (elapsed >= dist.get(node)) return;

            dist.put(node, elapsed);
            /** Node **/              /** 消耗時間 **/
            if (graph.containsKey(node))   for (int[] info: graph.get(node))   dfs(graph, info[1], elapsed + info[0]);
        }
    }



}
