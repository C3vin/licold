public class _55_Jump_Game {

    public static void main(String[] args) {


        int[] a = {3,2,1,0,4};

        Solution_1 solution_1 = new Solution_1();

        System.out.println(solution_1.canJump(a));
    }

    /** Backtracking  **/
    public static class Solution_1 {

        public boolean canJump(int[] nums) {
            return canJumpFromPosition(0, nums);
        }

        public boolean canJumpFromPosition(int position, int[] nums) {

            /** 1. 如果可以跳到最後一個點，當然返回true  **/
            if (position == nums.length - 1) return true;

            /** 2. 求可以跳的，最遠距離 **/
            int furthestJump = Math.min( position + nums[position],  nums.length - 1);

            /** 3. 在可跳的範圍內，遍歷  **/
            for (int n = position + 1; n <= furthestJump; n++) {

                /** ~1 測試下一個點 **/
                if (canJumpFromPosition(n, nums)) return true;
            }

            return false;
        }


    }

    /** Dynamic Programming Top-down **/

    /** 製造枚舉參數  **/
    enum Index { GOOD, BAD, UNKNOWN };

    public static class Solution_2 {

        /** 1. 制造 DP記憶體  **/
        Index[] memo;

        /** 2. 主函數  **/
        public boolean canJump(int[] nums) {

            /** 2.1 初始化memo，為nums的長度 **/
            memo = new Index[nums.length];

            /** 2.2 全部賦值為 UNKNOWN  **/
            for (int i = 0; i < memo.length; i++) {
                memo[i] = Index.UNKNOWN;
            }

            /** 2.3 nums最後一個為Good  **/
            memo[memo.length - 1] = Index.GOOD;

            /** 2.4 開始戰鬥 **/
            return canJumpFromPosition(0, nums);
        }

        /** 2.4 開始戰鬥 **/
        public boolean canJumpFromPosition(int position, int[] nums) {

            /** ~1 檢查當前位置，是否已經有答案**/
            if (memo[position] != Index.UNKNOWN) return memo[position] == Index.GOOD ? true : false;

            /** ~2 拿到最遠的旅行距離 **/
            int furthestJump = Math.min(position + nums[position], nums.length - 1);

            /** ~3 測試每個旅行距離內的點  **/
            for (int n = position + 1; n <= furthestJump; n++) {

                /** ~3.1 如果遞歸為True  **/
                if (canJumpFromPosition(n, nums)) {
                    memo[position] = Index.GOOD;
                    return true;
                }
            }

            memo[position] = Index.BAD;
            return false;
        }
    }

    /** Greedy **/
    public static class Solution_3 {

        public boolean canJump(int[] nums) {

            /** 1. 求最後的位置  **/
            int lastPos = nums.length - 1;

            /** 2. 從後往前算  **/
            for (int i = nums.length - 1; i >= 0; i--) {

                /** 如果當前位置，加上當前位置的值，大於lastPos，就更新 lastPos 為i  **/
                if (i + nums[i] >= lastPos) lastPos = i;
            }

            /** 3. 看是否可以找到最開頭位置  **/
            return lastPos == 0;
        }
    }
}
