import java.util.*;

public class _684_Redundant_Connection {

    public static void main(String[] args) {

        int[][] a = {{1,2}, {2,3}, {3,4}, {1,4}, {1,5}};

        Solution_1 solution_1 = new Solution_1();
        Solution_2 solution_2 = new Solution_2();

        int[] m = solution_1.findRedundantConnection(a);
        int[] n = solution_1.findRedundantConnection(a);

        for (int i : m) System.out.println(i);

        System.out.println("我是切割線");

        for (int i : n) System.out.println(i);

    }

    /**  Union Find:  DSU without Union-By-Rank  **/
    static class Solution_1 {

        int MAX_EDGE_VAL = 1000;  /** at most 1000 edges - refer to question description **/

        public int[] findRedundantConnection(int[][] edges) {

            DSU dsu = new DSU(MAX_EDGE_VAL + 1);

            for (int[] edge: edges) {

                if ( !dsu.union( edge[0], edge[1] ) ) return edge;
            }

            throw new AssertionError();
        }

        class DSU {   /**  Disjoint Set Union = Union Find **/

            int[] parent;
            int[] rank;

            public DSU(int size) {

                /** Initiate "parent" array  **/
                parent = new int[size];
                for (int i = 0; i < size; i++) parent[i] = i;

                /** Initiate "rank" array  **/
                rank = new int[size];
            }

            public int find(int x) {

                if (parent[x] != x) parent[x] = find(parent[x]);

                return parent[x];
            }

            public boolean union(int x, int y) {

                int xr = find(x), yr = find(y);

                if (xr == yr) return false;

                else if (rank[xr] < rank[yr]) {
                    parent[xr] = yr;
                }

                else if (rank[xr] > rank[yr]) {
                    parent[yr] = xr;
                }

                else if (rank[xr] == rank[yr]){
                    parent[yr] = xr;
                    rank[xr]++;
                }
                return true;
            }
        }

    }
    /**  Another Union Find: **/
    static class Solution_2 {

        public int[] findRedundantConnection(int[][] edges) {

            int n = edges.length + 1;

            UF uf = new UF(n);

            Map<Integer, List<Integer>> map = new HashMap<>();
            List<int[]> l = new ArrayList();
            for (int[] e : edges) {
                if (!uf.union(e[0], e[1])) l.add(e);
            }
            for (int[] i : l) {
                System.out.println(Arrays.toString(i));
            }
            return l.get(l.size() - 1);
        }

        class UF {

            Subset[] sub;

            public UF(int size) {

                sub = new Subset[size];

                for (int i = 0; i < size; i++) {

                    sub[i] = new Subset();
                    sub[i].parent = i;
                    sub[i].rank = 0;
                }
            }

            int find(int x) {
                if (x != sub[x].parent) {
                    sub[x].parent = find(sub[x].parent);
                }
                return sub[x].parent;
            }

            boolean union(int x, int y) {

                int xr = find(x);
                int yr = find(y);

                //if they are already part of same parent return false, they don't need to
                //combine
                if (xr == yr)
                    return false;

                if (sub[xr].parent < sub[yr].parent) {  sub[xr].parent = sub[yr].parent;

                } else if (sub[xr].parent > sub[yr].parent) {  sub[yr].parent = sub[xr].parent;

                } else {  sub[xr].parent = sub[yr].parent;  sub[yr].rank++;

                }
                return true;
            }
        }

        class Subset {
            int parent;
            int rank;
        }
    }
}





