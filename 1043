public class _1043_Partition_Array_for_Maximum_Sum {

    public static void main(String[] args) {

        int[] A = {1,15,7,9,2,5,10};
        int K = 3;


        Solution_1 solution_1 = new Solution_1();
        Solution_2 solution_2 = new Solution_2();

        System.out.println(solution_1.maxSumAfterPartitioning(A,K));
        System.out.println(solution_2.maxSumAfterPartitioning(A,K));

    }

    /** DP 67% **/
    public static class Solution_1 {

        /**
         * dp[i] record the maximum sum we can get considering A[0] ~ A[i]
         *
         * To get dp[i], we will try to change k last numbers separately to the maximum of them,
         * where k = 1 to k = K.
         * **/

        public int maxSumAfterPartitioning(int[] A, int K) {

            int N = A.length;   /** Array's length -->  N  **/

            int dp[] = new int[N];   /** dp array length --> N  **/


            for (int i = 0; i < N; ++i) {  /** Check each N **/

                    int curMax = 0;

                    /** Check small k positions before N */
                    for (int k = 1; k <= K && i - k + 1 >= 0 ; ++k) {

                        /** get the maximum value for current partition **/
                        curMax = Math.max(curMax, A[i - k + 1]);

                        /** update the dp[]  **/
                        dp[i] = Math.max( dp[i], (i >= k ? dp[i - k] : 0)  +  curMax * k );
                    }
            }

            return dp[N - 1];
        }
    }

    /** DP 98% **/
    public static class Solution_2 {

        public int maxSumAfterPartitioning(int[] A, int K) {

            int[] memo = new int[A.length]; /** make an memo[] withe length = A.length **/

            memo[0] = A[0];  /** initiate memo[0] as A[0] **/

            int initMax = A[0]; /** initiate the Max as A[0] **/

            for (int i = 1; i < K; ++i) {

                if (A[i] > initMax) {

                    initMax = A[i];
                }

                memo[i] = (i + 1) * initMax;
            }

            /** initiate the first 3 elements in memo[]  **/

            /**         A = [ 1,15,7,9,2,5,10 ]
             *     memo[] = [ 1 30 45 0 0 0 0 ]
             *  **/

            /** Traverse all the elements **/
            for (int i = K; i < A.length; ++i) {

                int cur = 0;

                int M = A[i]; /** find the Max value in the partition */
                
                for (int j = 1; j <= K; ++j) {

                    if (A[i - j + 1] > M)  M = A[i - j + 1]; /** always get the largest element **/

                    cur = memo[i - j] + j * M;  /** previous memo[] value + current partition summary **/
                    if (cur > memo[i])  memo[i] = cur;  /** update the memo[i] within the partition loop  **/
                }
            }
            return memo[A.length - 1];
        }
    }
}
