public class _708_Insert_into_a_Cyclic_Sorted_List {

    public static void main(String[] args) {


        Node a8 = new Node();
        Node a6 = new Node();
        Node a12 = new Node();

        a8.next = a6; a6.next = a12; a12.next = a8;
        a8.val = 3;   a6.val  = 7;   a12.val = 14;


        Solution_2 solution_2 = new Solution_2();
        Solution_1 solution_1 = new Solution_1();

        System.out.println(solution_1.insert(a8,9).val);
        System.out.println(solution_2.insert(a8,9).val);


    }

    // Test case 1:  insert(null, 1)
    // Test case 2:  insert(1->null, 0)
    // Test case 3:  insert(1->null, 1)
    // Test case 4:  insert(1->null, 2)
    // Test case 5:  insert(1->1->1->null, 0)
    // Test case 6:  insert(1->1->1->null, 1)
    // Test case 7:  insert(1->1->1->null, 2)
    // Test case 8:  insert(1->1->3->3->null, 0)
    // Test case 9:  insert(1->1->3->3->null, 1)
    // Test case 10: insert(1->1->3->3->null, 2)
    // Test case 11: insert(1->1->3->3->null, 3)

    static class Node {
        public int val;
        public Node next;

        public Node() {}

        public Node(int _val,Node _next) {
            val = _val;
            next = _next;
        }
    };

    /** 1. One Pass  **/
    static class Solution_1 {

        /** 主函數  **/
        public Node insert(Node start, int x) {

            /** 1. 邊界條件   **/
            // if start is null, create a node pointing to itself and return
            if (start == null) {
                Node node = new Node(x, null);
                node.next = node;
                return node;
            }

            /** 2. 製造 cur **/
            Node cur = start;

            /** 3. 開始戰鬥  **/
            while (true) {

                /** 3.1 如果還在增加  **/  // case 1A: has a tipping point, still climbing
                if (cur.val < cur.next.val) {
                    if (cur.val <= x && x <= cur.next.val) { // x in between cur and next
                        insertAfter(cur, x);
                        break;
                    }

                /** 3.2 零界點  **/    // case 1B: has a tipping point, about to return back to min node
                } else if (cur.val > cur.next.val) {
                    if (cur.val <= x || x <= cur.next.val) { // cur is the tipping point, x is max or min val
                        insertAfter(cur, x);
                        break;
                    }
                /** 3.3 零全部是平的  **/    // case 2: NO tipping point, all flat
                } else {
                    if (cur.next == start) {  // insert x before we traverse all nodes back to start
                        insertAfter(cur, x);
                        break;
                    }
                }

                /** 3.4 和目前的Cur一樣，就下一個  **/// None of the above three cases met, go to next node
                cur = cur.next;
            }

            return start;
        }

        /** 插入 **/
        private void insertAfter(Node cur, int x) {


            cur.next = new Node(x, cur.next /** 先運行這個 **/ );
        }
    }


    /** 2. Two Passes **/
    static class Solution_2 {

        public Node insert(Node start, int x) {

            /** 1. 邊界條件 **/
            // if start is null, create a node pointing to itself and return
            if (start == null) {
                Node node = new Node(x, null);
                node.next = node;
                return node;
            }

            /** 2. 開始插入 **/
            // if start is not null, try to insert it into correct position

            /** 3. 製造cur  | 1st pass **/
            // 1st pass to find max node
            Node cur = start;

            /** 4. 找到最大的點 **/
            while (cur.val <= cur.next.val && cur.next != start) cur = cur.next;

            /** 5. 制造 | 2nd pass **/
            // 2nd pass to insert the node in to correct position
            Node max = cur;

            /** 6. dummy指向最大node的下一個  **/
            Node dummy = new Node(0, max.next); // use a dummy head to make insertion process simpler

            /** 7. max下一個斷開  **/
            max.next = null; // break the cycle

            /** 8. dummy給cur  **/
            cur = dummy;

            /** 9. 一直找到正確的位置  **/
            while (cur.next != null && cur.next.val < x) {
                cur = cur.next;
            }

            /** 10. 插入 **/
            cur.next = new Node(x, cur.next); // insert

            /** 11. 重新建環，看下這裡的巧妙 **/
            Node newMax = max.next == null ? max : max.next; // reconnect to cycle

            /** 12. 環閉  **/
            newMax.next = dummy.next;


            return start;
        }
    }



}
