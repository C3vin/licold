public class _959_Regions_Cut_By_Slashes {

    public static void main(String[] args) {

        String[] a = {" /","/ "};
        String[] b = {" /","  "};
        String[] c = {"\\/","/\\"};
        String[] d = {"/\\", "\\/"};
        String[] e = { "//", "/ "};

        String[] f = { "// ", "/\\ ", "///"};


        Solution_1 solution_1 = new Solution_1();

        System.out.println(solution_1.regionsBySlashes(a));
        System.out.println(solution_1.regionsBySlashes(b));
        System.out.println(solution_1.regionsBySlashes(c));
        System.out.println(solution_1.regionsBySlashes(d));
        System.out.println(solution_1.regionsBySlashes(e));
        System.out.println(solution_1.regionsBySlashes(f));

    }

    /** Union Find <-- cut the cube into four pieces | Without ranking **/
    static class Solution_1 {

        public int regionsBySlashes(String[] grid) {

            int N = grid.length; /** the grid's length is the cube's height **/

            DSU dsu = new DSU(4 * N * N);   /** Here we cut the one single grid into four pieces two knives "\" and "/" **/


            for (int r = 0; r < N; ++r)    /** Traverse the grid height (row) **/

                for (int c = 0; c < N; ++c) {       /** Traverse the grid width （column）**/

                    int root = 4 * (r * N + c);     /** record the total number of root so far, at this moment **/

                    char val = grid[r].charAt(c);   /** Check this cube's input --> "\" or "/" or " " **/

                    if (val != '\\') {

                        dsu.union(root + 0, root + 1);
                        dsu.union(root + 2, root + 3);
                    }

                    if (val != '/') {

                        dsu.union(root + 0, root + 2);
                        dsu.union(root + 1, root + 3);
                    }

                    // north south
                    if (r + 1 < N) /** if next row exist  **/
                        dsu.union(root + 3 /** bottom chunk of current cube **/, (root + 4 * N) + 0 /** top chunk of the below cube **/);

                    if (r - 1 >= 0) /** if previous row exist  **/
                        dsu.union(root + 0, (root - 4 * N) + 3);

                    // east west
                    if (c + 1 < N) /** if next column exist  **/
                        dsu.union(root + 2, (root + 4) + 1);

                    if (c - 1 >= 0)  /** if previous column exist  **/
                        dsu.union(root + 1, (root - 4) + 2);
                }

            int ans = 0;
            for (int x = 0; x < 4 * N * N; ++x) {
                if (dsu.find(x) == x)
                    ans++;
            }

            return ans;
        }
    }

    static class DSU {

        int[] parent;

        public DSU(int N) {

            parent = new int[N];
            for (int i = 0; i < N; ++i) parent[i] = i;
        }

        public int find(int x) {

            if (parent[x] != x) parent[x] = find(parent[x]);
            return parent[x];
        }

        public void union(int x, int y) {

            parent[find(x)] = find(y);
        }
    }




    /** DFS | with ranking **/
    public static class solution_2 {

        int n;
        int count;

        int[] f;

        public int regionsBySlashes(String[] grid) {

            n = grid.length;
            count = n * n * 4;

            /** Prepare father or parent array  **/
            f = new int[n * n * 4];
            for (int i = 0; i < n * n * 4; ++i) f[i] = i;

            for (int i = 0; i < n; ++i) { /** traverse row **/

                for (int j = 0; j < n; ++j) { /** traverse column  **/

                                         /** bottom **/       /** current up **/
                    if (i > 0) union(g(i - 1, j, 2), g(i, j, 0));

                                         /** right **/       /** current left **/
                    if (j > 0) union(g(i, j - 1, 1), g(i, j, 3));

                    if (grid[i].charAt(j) != '/') {

                        union(g(i, j, 0), g(i, j, 1));
                        union(g(i, j, 2), g(i, j, 3));
                    }

                    if (grid[i].charAt(j) != '\\') {

                        union(g(i, j, 0), g(i, j, 3));
                        union(g(i, j, 2), g(i, j, 1));
                    }
                }
            }
            return count;
        }



        public int find(int x) {
            if (x != f[x]) {
                f[x] = find(f[x]);
            }
            return f[x];
        }

        public void union(int x, int y) {
            x = find(x);
            y = find(y);
            if (x != y) {
                f[x] = y;
                count--;
            }
        }

        public int g(int i, int j, int k) {
            return (i * n + j) * 4 + k;
        }

    }
}
